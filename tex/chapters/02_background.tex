\chapter{Background}
\label{chap:background}


\section{Mathematical logic}

Mathematical logic is useful for deciding correctness of systems. This section provides some insight about propositional logic, first order logic, and the satisfiability problem. Difference logic is also introduced.

\subsection{Propositional logic}

Propositional logic is concerned with the study of formulae of boolean variables, and deciding whether they are true or false under a given assignment. Propositional formulae are composed of \emph{truth symbols} $\top$ (true) and $\bot$ (false),  and propositional \emph{variables} $p,q, \dots$ with the use of \emph{logical connectives}. A formula $\varphi$ can be an \emph{atom} (a truth symbol or a variable) or can be constructed from other logical formulae with the following connectives:

\begin{itemize}
	\item negation: $\neg\varphi$ is evaluated true iff $\varphi$ is evaluated false (formal equivalent of 'not'),
	\item conjunction: $\varphi_1 \wedge \varphi_2$ is evaluated true iff  both $\varphi_1$ and $\varphi_2$ are evaluated true (formal equivalent of 'and'),
	\item disjunction: $\varphi_1 \vee \varphi_2$ is evaluated true iff  at least one of $\varphi_1$ and $\varphi_2$ is evaluated true (formal equivalent of 'or'),
	\item implication: $\varphi_1 \to \varphi_2$ is evaluated true iff  $\varphi_1$ is evaluated false or both $\varphi_1$ and $\varphi_2$ are evaluated true (formal equivalent of 'if \ldots then'),
	\item equivalence: $\varphi_1 \leftrightarrow \varphi_2$ is evaluated true iff   both $\varphi_1$ and $\varphi_2$ are evaluated true or  both $\varphi_1$ and $\varphi_2$ are evaluated false (formal equivalent of 'if and only if').
\end{itemize}

\emph{Note:} disjunction, implication, and equivalence can be expressed using negation and conjunction. These operators are only defined to simplify usage.

The (boolean) satisfiability problem (SAT, for short) can be defined as follows \cite{biere2009handbook}.
\begin{description}
	\item[Input]: A propositional logic formula $\varphi$.
	\item[Output]: \emph{Yes} if $\varphi$ is satisfiable (i.e. it is possible to ground the variables appearing in $\varphi$ to truth symbols so that $\varphi$ is evaluated true), \emph{No} otherwise.
\end{description}

Although SAT is NP-complete in theory \cite{Cook71}, modern SAT solvers can solve large problems in practical applications \cite{oai:hal.archives-ouvertes.fr:hal-00868244}.

\subsection{First order logic}

Propositional logic is useful, however, sometimes its expressive power is not enough. First order logic is a extends propositional logic with predicate symbols, function symbols and quantifiers $\exists$ (existential quantifier) and $\forall$ (universal quantifier). 

%While propositional logic formulae could only be evaluated to truth values, first order logic formulae can be evaluated to numbers, functions or any abstract concept.

The basic elements of first order logic are \emph{terms}. Variables and constant symbols (0-ary function symbols) are terms, as well as $n$-ary functions applied to $n$ terms. In first order logic an atom can be $\top, \bot$ or an a $n$-ary predicate symbol applied to $n$ terms. Formulae are constructed by applying connectives (the same as in case of propositional logic) and quantifiers to atoms.

The satisfiability problem can be extended to first order logic formulae, but it is undecidable \cite{Church36a,Turing36}. However, there is a variant of the problem that is applicable, and solvable for most practical problems. The key idea is to formalize structures.

\begin{dfn}
	A \emph{first order theory} $\mathcal{T}$ is a pair $(\Sigma,\mathcal{A})$ \cite{books/daglib/0019162} where 
	\begin{itemize}
		\item $\Sigma$ is the \emph{signature}, i.e. the set of constant, function and predicate symbols and
		\item $\mathcal{A}$ is the set of \emph{axioms} where an axiom is a first order logic formula that has no quantifiers in it, and $\Sigma$ contains all constants, functions and predicates appearing in it.
	\end{itemize}
\end{dfn}

The \emph{Satisfiability Modulo Theories} problem (SMT for short) can be defined as follows.
\begin{description}
	\item[Input]: A theory $\mathcal{T}=(\Sigma,\mathcal{A})$, and $\Sigma$-formula $\varphi$.
	\item[Output]: \emph{Yes} if $\varphi$ is satisfiable in $\mathcal{T}$, \emph{No} otherwise.
\end{description}

In many practical theories (e.g. linear arithmetic, that is often used in software development) SMT becomes decidable \cite{series/txtcs/KroeningS08}. In my work I use difference logic which is one of the theories where satisfiability is decidable.

\subsection{Difference logic}

An atom in (integer) difference logic is a logical expression of the form $x-y<n$ or $x-y \leq n$ where $x$ and $y$ are variables defined over $\mathds{Z}$ and $n$ is a constant. A difference logic formula $\varphi$ is a conjunction of one ore more atoms. In case of difference logic, satisfiability is not only decidable, but decidable in polynomial time \cite{series/txtcs/KroeningS08}.

Since the framework presented in this paper relies on a SAT (SMT) solver (as it is explained in Chapter \ref{chap:impl}), this paper does not address the algorithms for deciding satisfiability (if it is decidable). For more information on satisfiability, the reader is referred to \cite{books/daglib/0019162}.


\section{Formal verification}

Formal verification is the act of proving the correctness or incorrectness of a system in a mathematically precise way. Model checking is an automatic formal verification technique based on systematic state space traversal of system, where the system has to be represented by a formal model, and the requirements of the system has to be a property of the system formally defined as logical formulae \cite{clarke_em-etal:1999a}. Verification can be performed by proving that the system (represented by the formal model) satisfies that property.

\subsection{Modelling formalisms}
It is important to find the appropriate representation of the model i.e. the appropriate formalism in order to be able to model and check the property. This paper focuses on \emph{behavior properties} examined on \emph{behavioral models}. 

In formal verification behaviour is often represented with state-based formalisms: the system's behaviour is partitioned to a (not necessarily finite) set of \emph{states} (the \emph{state space}), that is complete and excluding -- i.e. at any given time the system is in exactly one of the states. The state of the system determines the possible behaviours. Because of this, it is important to choose the granularity of the state space in a way that it can be decided what behaviour is possible and what is not, solely based on the system's current state.

\subsubsection{Finite automata}

The formalism of finite automata  is one of the most common formalisms for modelling behaviour. This way the system is described by a finite set of possible states, and a set of steps defining the system's state changes.

\begin{dfn}
	Formally a \emph{finite automaton}, or state machine $\mathcal{A}$ is a tuple $\langle S,s_0,T \rangle$ where
	\begin{itemize}
		\item $S$ is a finite set of states,
		\item $s_0 \in S$ is the initial state and
		\item $T \subseteq (S \times S)$ is a set of transitions.
	\end{itemize}
\end{dfn}


Structurally $\mathcal{A}$ can be represented as a directed graph $G_\mathcal{A}$ where $V(G_\mathcal{A})=S$ and $E(G_\mathcal{A}})=T$. The system's operation is described as follows.

Initially, the system is in $s_0$. The system can change its state to some other state $s_1$ iff $(s_0,s_1) \in T$. from $s_1$ it can change its state to $s_2$ iff $(s_1,s_2) \in T$, and so on. 

%\begin{figure} [b]
%	\centering
%	\begin{minipage}[c] {0.25\linewidth}%
%		\vspace*{1pt}%
%		\includegraphics [width=\textwidth]{include/figures/loop_example_original}%
%		\caption{Example of a timed automaton}
%	\end{minipage}%
%	%
%	\begin{minipage}[c] {0.7\linewidth}%
%		\includegraphics [width=\textwidth] {include/figures/loop_original_zonegraph}%TODO: ezt majd még vektorosítani
%		\vspace*{4pt}%
%		\caption{Timed automaton}
%	\end{minipage}
%	\caption{Timed automaton with infinite zone graph}
%	\label{fig:loopinfinite}
%\end{figure} 

\begin{figure}
	\centering
	\begin{minipage}{0.5\textwidth}
		\includegraphics[width=\textwidth]{include/figures/loop_example_unclocked}%
		\caption{Example of a finite automaton}
		\label{fig:faex}
	\end{minipage}
\end{figure}

\begin{example}
	Let $\mathcal{A}$ be a finite automaton with states \emph{start}, \emph{loop}, and \emph{end}, and transitions  \emph{start} $\to$ \emph{loop}, \emph{loop} $\to$ \emph{loop}, and \emph{loop} $\to$ \emph{end}, as depicted in Figure \ref{fig:faex}. The initial state is \emph{start}, denoted by double outline.
	
	Operation starts form the initial state, \emph{start}. The system can step to \emph{loop} where it can step to \emph{end} or \emph{loop} (itself). Since it is always a possibility to stay in the current state, loop transitions don't have importance in finite automata.
\end{example}

This formalism is easy to use and verify, but its expressive power is not sufficient: there are many types of behaviours that can't be modelled this way.

\subsubsection{Finite automaton extended with variables} \label{sec:extfa}

Many extensions of the finite automaton are known with various levels of expressive power. The following extension lifts the level of expressive power to that of Turing-machines: extending the automaton with variables.


\begin{dfn}
A finite automaton extended by variables could be (briefly) defined as a tuple $\langle L,l_0,v_0, E, I\rangle$ operating on a set of variables $\mathcal{V}$ where
\begin{itemize}
	\item $L$ is the set of control locations,
	\item $l_0 \in L$ is the initial location,
	\item $v_0$ is a function assigning an initial value to each variable $x \in \mathcal{V}$,
	\item $E \subseteq L \times \mathcal{B} \times \mathcal{U} \times L$ is the set of edges (where $\mathcal{B}$ can be briefly described as the set of bool valued first order logic formulae constructed from the variables of $\mathcal{V}$,  and $\mathcal{U}$ can briefly defined as the set of unary functions operating on subsets of $\mathcal{V}$  assigning new values to variables) and
	\item $I: L \to \mathcal{B}$ is a function assigning invariants to locations.
\end{itemize}
\end{dfn}

Since these automata's behaviour depends on the current values of the variables (the  current \emph{valuation}), the basic parts of the model can not be called states.
Instead, they are called control locations. For similar reasons, the edges of the graph are now called edges in the formalism as well, and they are more expressive: an edge $e=(l,g,a,l')$ represents a transition form $l$ to $l'$, with a guard $g$ and an assignment function $a$. A guard is a condition that has to be satisfied in order for the transition to be enabled. The function $a$ describes how the values of some variables are changed during the transition. Locations can have invariants, that are conditions that have to be satisfied while the system stays in that location.

The system's operation starts from the control location $l_0$, and the variables are initialized as $v_0$ defines. A system can transition from $l$ to some $l'$ if there exist an edge $e=(l,g,a,l')$ where $g$ is satisfied by the variables current values, and $I(l')$ is satisfied by the values $a$ assigns to the variables (or their current value if $a$ is undefined on them).

\begin{figure}
	\centering
	\begin{minipage}{0.6\textwidth}
		\includegraphics[width=\textwidth]{include/figures/loop_example_discrete}%
		\caption{Extended finite automaton}
		\label{fig:efaex}
	\end{minipage}
\end{figure}

\begin{example}
	Let $\mathcal{A}$ be an extended version of the automaton in Figure \ref{fig:faex} as depicted in Figure \ref{fig:efaex}. The introduced variables are $x$ and $l$. The variable $l$ is used as a loop counter. The edge \emph{start} $\to$ \emph{loop} assigns 2 to $x$, \emph{loop} $\to$ \emph{loop} squares $x$ and increases the value of the loop counter, \emph{loop} $\to$ \emph{end} doesn't affect the values of the variables, but it is only enabled when $x$ is a least 16. Location \emph{loop} has an invariant ensuring that the loop edge is taken at most 5 times.
	
	Operation starts in state $\langle \text{\emph{start}}, x=0, l=0\rangle$. When the system changes its state it can only take edge \emph{start} $\to$ \emph{loop}, resulting in state $\langle \text{\emph{loop}} x=2, l=0 \rangle$. Edge  \emph{loop} $\to$ \emph{end} is not enabled, but the system can take the loop edge resulting in state $\langle \text{\emph{loop}} x=4, l=1\rangle$. The edge to \emph{end} is still not enabled, but after taking the loop edge again ($\langle \text{\emph{loop}} x=16, l=2\rangle$) it becomes enabled. The system may keep taking the loop edge up to three times (after which the invariant prohibits it, because it would increase $l$), or transition to \emph{end}.
\end{example}

\subsection{Reachability analysis}
During formal verification, one of the most important questions is reachability: deciding whether a system can step into a given state. In many cases, the state in question represents an erroneous state and the desired outcome of model checking is that it is unreachable. The problem can be defined as follows.
\begin{description}
	\item[Input]: A system $S$ and a state $s_{err}$.
	\item[Output]: \emph{Yes} if it is possible for $S$ to operate in a way that it eventually steps in $s_{err}$, \emph{No} otherwise.
\end{description}

When the answer is \emph{Yes}, it is useful to provide a \emph{counterexample}: an execution trace $\sigma = s_0 \to s_1 \to \cdots \to s_{err}$ setting the system's state to $s_{err}$ where $s_i$-s are states  and $s_i \to s_{i+1}$ notations represent possible transitions of the system from $s_i$ to $s_{i+1}$.

Each formalism has its own interpretation of the problem -- regarding how erroneous states and execution traces are described. For example, in case of finite automata, the problem can be interpreted as follows. 

\begin{description}
	\item[Input]: A finite automaton $\mathcal{A}=\langle S,s_0,T\rangle$ and a state $s_{err} \in S$.
	\item[Output]: A sequence of states and transitions $\sigma = s_0 \xrightarrow{t_0} s_1 \xrightarrow{t_1} \cdots \xrightarrow{t_n} s_{n+1}=s_{err}$ ($s_i \in S, t_i=(s_i,s_{i+1}) \in T$ for all $0 \leq i \leq n$) if the $\mathcal{A}$ can reach $s_{err}$ , \emph{No} otherwise.
\end{description}

This problem can be solved by any pathfinding algorithm (e.g. breadth first search or depth first search) executed on $G(\mathcal{A})$, where $G(\mathcal{A})$ denotes the graph representation of a finite automaton $\mathcal{A}$.

\begin{example}
	Let the input be the previous automaton in Figure \ref{fig:faex} and it's state \emph{end}. A pathfinding algorithm finds a path, e.g. \emph{start} $\to$ \emph{loop} $\to$ \emph{end}, proving the state is reachable. 
\end{example}

In case of extended finite automata the problem can be interpreted as follows.
\begin{description}
	\item[Input]: A finite automaton $\mathcal{A}=\langle L,l_0,v_0, E, I\rangle$ and a control location $l_{err} \in L$.
	\item[Output]: A sequence of locations and enabled transitions $\sigma = l_0 \xrightarrow{e_0} l_1 \xrightarrow{e_1} \cdots \xrightarrow{e_n} l_{n+1}=l_{err}$ if the $S$ can reach $s_{err}$, \emph{No} otherwise.
\end{description}

Note, that in this case error states are defined solely by the location, however, it is easy to reduce a problem where the values of the variables are also constrained into this form.

\begin{figure}
	\centering
	\begin{minipage}{0.7\textwidth}
		\includegraphics[width=\textwidth]{include/figures/loop_example_error}%
		\caption{Automaton for checking reachability}
		\label{fig:efaexerr}
	\end{minipage}
\end{figure}

\begin{example}
	Consider the previous system $\mathcal{A}$ depicted in Figure \ref{fig:efaex} with the erroneous states defined as the set of states where the current location is \emph{end} and $x \geq 200$.
	
	A new automaton can be constructed by extending $\mathcal{A}$'s set of location with a new location \emph{error} that is only reachable if $\mathcal{A}$ can reach location \emph{end} with $x \geq 200$. The new automaton is depicted in Figure \ref{fig:efaexerr}.
\end{example}

The described problem is unsolvable as well as the reachability problem for all other Turing-complete formalisms. This is one of the reasons why the modelling formalism has to be chosen carefully. A simple formalism may not have enough expressive power to precisely model the system, while verification of more complex formalisms may be ineffective or even impossible.

\subsubsection{State space exploration}

Even if reachability is undecidable (or just inefficient), there are many methods and approaches on how to gain useful information on the problem. The most obvious approach is \emph{state space exploration}.

\begin{dfn}
	The \emph{state space} of a system is the set of states that are reachable from the initial state by a sequence of enabled transitions. 
\end{dfn}

The idea of state space exploration is to systematically enumerate all possible states in the state space. If the erroneous state is found, the system is proven to be incorrect. Otherwise if all possible states are listed (in case of a finite state space) and no erroneous state is found, the system is proven to be correct. (In case of an infinite state space this naive procedure will never terminate.)

One of the simplest ways to explore the state space is to construct a search-tree. The root of the tree is the initial state $s_0$ of the system. The state space is explored by iteratively choosing a leaf with a state $s$ of the tree, and introducing a new edge for all possible enabled transitions $(s,s')$ pointing to a new node with a state $s'$. This way, all possible execution traces are explored, but states may appear more than once if there are more execution traces to reach them.

It is also possible to construct a state graph, where the state space is explored similarly, except one state can only appear once. This helps reducing the size of the graph, however (in case of an infinite state space) it still might be infinite. Infinite state spaces can never be completely explored this way (by explicit exploration), however, sometimes, when small counterexamples are expected, it is not necessary.

Consider the \emph{bounded reachability problem}.
\begin{description}
	\item[Input]: A system $S$, a state $s_{err}$, and a bound $k$.
	\item[Output]: A counterexample, if $S$ can reach $s_{err}$ in at most $k$ transitions, \emph{No} otherwise.
\end{description}

This problem is decidable, even for finite automata with variables. Even so, explicit state space exploration can not be considered an efficient method.

\subsection{CEGAR}

One of the possible approaches to perform model checking more efficiently is to use abstraction \cite{Clarke:1994:MCA}. A less detailed system model is constructed that hides unimportant parts of the behavior providing a model of complex state space overapproximating the original one. The idea of counterexample guided abstraction refinement (CEGAR) \cite{clarke2003counterexample} is to apply 
model checking to this simpler model, and then examine the results on the original one. The idea is illustrated in
Figure \ref{fig:cegar}.


\begin{figure}
	\centering
	\includegraphics [width=0.7\textwidth] {include/figures/cegar_flow_black}
	\caption{Counterexample-guided abstraction refinement}
	\label{fig:cegar}
\end{figure}

%The CEGAR approach introduced in \cite{clarke2003counterexample} makes
%abstraction refinement a key part of model checking. 

First, an abstract system is constructed. The key property of abstraction is
that the state space of the abstract system overapproximates that of the original
one, but it is less complex and thus model checking can be performed more efficiently on the abstract system.

Model checking is performed on the abstract model. If the target state is
unreachable in the abstract model, it is unreachable in the original model
as well. Otherwise the model checker produces an abstract counterexample -- an execution trace demonstrating how the abstract
system can reach the target state. 

Overapproximation admits behaviours of the system that are not feasible in the original one and the counterexample may not be a valid trace in the real system, so it has to be examined.
If it turns out to be a feasible counterexample, the target state is reachable. Otherwise
the abstract system has to be refined -- hidden details of the original system have to be reintroduced to the model. The goal of the refinement is to modify the abstract
system so that it remains an abstraction of the original one, but the spurious
counterexample is eliminated.  Model checking is performed on the
refined system, and the CEGAR loop starts over. 

The algorithm terminates when no more
counterexamples are found or when a feasible trace is
presented leading to the erroneous state.

There are many ways CEGAR can be implemented. The most important difference is the way abstraction is applied to the system. It determines the class of algorithms that can be used for model checking, the nature of the counterexample, and how it can be analyzed, and the possibilities for refinement. Two approaches are presented here that can be applied to a wide range of formalisms.

\subsubsection{Automaton abstraction example} \label{sec:cegarex1}

An abstraction method commonly used for formalisms operating on variables is to reduce the number of variables in the model, by simply ignoring some of them \cite{Clarke:1994:MCA}. The initial abstraction of the model can be the same model without any variables.
 
 \begin{example}
 	Consider again automaton $\mathcal{A}$ depicted in Figure \ref{fig:efaex}. Eliminating all variables results in the previous finite automaton depicted in Figure \ref{fig:faex}.
 \end{example}

Model checking can be performed by state space exploration for example, however, there are several other ways.

 \begin{example}
 	In the first iteration the state space exploration of $\mathcal{A}$ will result in $G(\mathcal{A})$, where the counterexample found can be e.g. $\sigma = \text{\emph{start}} \to \text{\emph{loop}} \to \text{\emph{end}}$.
 \end{example}
 
 A common way of checking whether a counterexample  is feasible is by transforming it into a first order logic formula, and handing it to a solver \cite{BCCZ99}. If it is satisfiable, the error location is reachable, and the system is incorrect. Consider for example the case of the extended finite automaton. The counterexample is a trace $\sigma = l_0 \xrightarrow{e_0} l_1 \xrightarrow{e_1} \cdots \xrightarrow{e_n} l_{n+1}=l_{err}$.

Variables have to be defined: for each $x \in \mathcal{V}$ variables $x_0,x_1, \dots, x_n$ and $x_{err}$ are defined -- one for each state on the counterexample. Afer that a set of constraints is constructed to define the automaton's behaviour. 

First, initial conditions are defined. In case of extended finite automata, the initial constraints are the variables' initial values. For each $x \in \mathcal{V}$ $x_0=v_0(x)$ is added to the set of constraints. After that, constraints are added step by step. 

It has to be checked if the guard is satisfied. For each $e_i=(l_i,g_i,a_i,l_{i+1})$ $0 \leq i \leq n$ a variation of $g_i$ is added to the set of constraints: all $x \in \mathcal{V}$ appearing in $g_i$ is replaced by $x_i$. After that, the assignment function is considered: for each $x \in \mathcal{V}$ $x_{i+1}=a_i(x)$ is added to the set of constraint if $a_i(x)$ exists, and $x_{i+1}=x_i$ is added otherwise. Invariants can be turned into constraints the same way as guards: all $x \in \mathcal{V}$ appearing in $I(l_i)$ is replaced by $x_i$. 

\begin{example}
	The translation of the counterexample $\sigma = \text{\emph{start}} \to \text{\emph{loop}} \to \text{\emph{end}}$ to a logic formula will contain variables $x_0,x_1,x_2,l_0,l_1$ and $l_2$. The initial constraints are $x_0=0,l_0=0$. Edge \emph{start} $\to$ \emph{loop} assigns 2 to $x$, but leaves $l$ unchanged, yielding the constraints $x_1=2,l_1=l_0$. Location \emph{loop}'s invariant $l \leq 5$ can be transformed to constraint $l_1 \leq 5$. The guard of \emph{loop} $\to$ \emph{end} yields the constraint $x_1 \geq 16$.
	
	The formula handed to the solver is $\varphi = x_0=0 \wedge l_0=0 \wedge x_1=2 \wedge l_1=l_0 \wedge l_1 \leq 5 \wedge x_1 \geq 16$.
\end{example}

The conjunction of the resulting set of constraints is handed to a solver. If it is satisfiable, the counterexample is feasible, and the erroneous state is reachable. Otherwise it is a spurious counterexample and the abstract system has to be refined. Solvers can be used for refinement as well, because they often provide additional information that helps choosing the hidden parts of the system that has to be reintroduced to the abstract representation in order to eliminate the counterexample.

\begin{example}
	The formula $\varphi = x_0=0 \wedge l_0=0 \wedge x_1=2 \wedge l_1=l_0 \wedge l_1 \leq 5 \wedge x_1 \geq 16$ is obviously unsatisfiable, because $x_1=2 \wedge x_1 \geq 16$ is unsatisfiable in itself. If the automaton's current abstraction is extended with the variable $x$ with all of its assignments, and all constraints in guards and invariants that $x$ appears but $l$ doesn't, this counterexample won't be found anymore.
\end{example}

\subsubsection{State space abstraction example} \label{sec:cegarex2}

Another possible approach is to apply the abstraction directly to the state space of the model. The difficulty in this is that the state space is unknown and the abstraction of the state space has to be yielded solely from the model and the examined property. In case of automaton-based formalisms, a simple solution is to start from the location graph of the automaton. This is an abstraction of the state space, because a node $l$ of the graph represents all states the system can take in location $l$, and an edge $e(l,l')$ can represents all transitions from the represented states of $l$ to $l'$ using $e$ in the automaton.

 \begin{example}
 	Consider again automaton $\mathcal{A}$ depicted in Figure \ref{fig:efaex}. The location graph is the previous finite automaton depicted in Figure \ref{fig:faex}.
 	
 	\emph{Note:} The initial abstraction is graphically the same as in case of the previous approach, but the interpretation is different.
 \end{example}

Since this approach operates on an abstraction of the state graph, model checking can be performed by a pathfinding algorithm. This will result in an execution trace, that has to be examined to decide if it is feasible, and if it turns out to be a spurious counterexample, the abstract state space has to be refined. Refinement divides the abstract states to smaller parts. Graphically this means some node $n$ representing the states $S$ are replicated (with each new node representing a subset of $S$), along with their edges -- but only if the represented transition is still valid. That is, when node $n$ representing states $S$ is refined to nodes $n_1,n_2,\dots$ representing states $S_1,S_2,\dots \subset S$ an edge $n \to n'$, where $n'$ represents states $S'$ is only replicated to $n_1 \to n'$ if there exists some $s \in S_1$ and $s' \in S'$ such that $s'$ can be reached from $s$ through a transition represented by the edge. (Incoming edges to $n$ can be handled similarly).

A task of the analysis phase is to determine the information to refine the nodes, based on the spurious counterexample, such that it is eliminated. A possible approach is to find the invalid transition of the spurious counterexample and derive a predicate that is true in the preceding state, and implies that the transition is invalid. (Solvers can be useful for performing this automatically.) This approach is called \emph{predicate abstraction} \cite{Graf97a}.

 \begin{example}
 	Consider the counterexample $\sigma = \text{\emph{start}} \to \text{\emph{loop}} \to \text{\emph{end}}$. Transition \emph{loop} $\to$ \emph{end} is obviously not satisfiable since in location \emph{loop} $x<16$. Dividing the node \emph{loop} by this results in two nodes: $l_1=\langle \text{\emph{loop}}, x<16 \rangle$ (where the predicate holds) and $l_2=\langle \text{\emph{loop}}, x \geq 16 \rangle$ (where the predicate does not hold in any represented states).
 	
 	Trivially the edge \emph{start} $\to$ \emph{loop} should only reappear pointing to $l_1$, and edge \emph{loop} $\to$ \emph{end} should only reappear pointing to $l_2$, but there are four ways the new versions of the loop edge can be positioned ($l_1 \to l_1$, $l_1 \to l_2$,$l_2 \to l_1$, and $l_2 \to l_2$). Edge $l_1 \to l_1$ should appear since if $x=0$ (note, at this point the only known fact about $x$ is that it is less than 16) $x'=0<16$ where $x'$ is the value of $x$ after the transition. Similarly $l_2 \to l_2$ is also valid since if $x=16$, then $x'=256 \geq 16$. Edge $l_1 \to l_2$ is also valid, since if $x=4<16$, then $x'=16 \geq 16$, but there is no such $x \geq 16$ that yields $x'<16$, thus this edge should not be created. 
 \end{example}


\section{Verification of timed systems}

The timed automaton is a common formalism for modelling timed systems. It is an extension of the finite automaton with clock variables. In this section clock variables and timed automata are introduced, an algorithm is described (and the implementation briefly explained) for deciding reachability, and information is provided on the complexity of the problem.

\subsection{Basic definitions}


In order to properly define timed automata, first the idea of \emph{clock variables} must be explained. In case of untimed systems, the values of the variables always remain the same between two modifications. However, this is not the case for clock variables (clocks, for short).

\begin{dfn}
	\emph{Clock variables} are a special type of variables, whose value is constantly and steadily increasing.
\end{dfn}

When a system stays in one state, the value of clocks are increasing. Naturally, their values can be modified, but the only allowed operation on clock variables is to \emph{reset} them. Resetting a clock means assigning its value to 0. It's an instantaneous operation, after which the value of the clock will continue to increase.

Hereinafter follows some basic definitions that are closely related to clock variables and timed automata. 

\begin{dfn}
	A \emph{valuation} $v(\mathcal{C})$ assigns a non-negative real value
	to each clock variable $c \in \mathcal{C}$, where $\mathcal{C}$ denotes the set of clock
	variables.
\end{dfn}

In other words a valuation defines the values of the clocks at a given moment of time, just like in case of discrete variables.

\begin{dfn}
	A \emph{clock constraint} is a conjunctive formula of atomic
	constraints of the form $x \sim n$ or $x - y \sim n$ (\emph{difference
		constraint}), where $x,y \in \mathcal{C}$ are clock variables, $\sim \in \{\leq,<,=,>,\geq\}$ and \hbox{$n \in \mathbb{N}$}. $\mathcal{B}(\mathcal{C})$ represents the set of clock
	constraints.
\end{dfn}

In other words a clock constraint defines upper and lower bounds on the values of clocks (or differences of clocks, in case of difference constraints). Bounds are always integer numbers.

A \emph{timed automaton} extends a finite automaton with clock variables. It can be defined as follows.

\begin{dfn}
A \emph{timed automaton} $\mathcal{A}$ is a tuple $\langle L, l_0,
E, I\rangle$ where
\begin{itemize}
	\item $L$ is the set of locations,
	\item $l_0 \in L$ is the initial location,
	\item $E \subseteq L \times \mathcal{B}(\mathcal{C}) \times 2^\mathcal{C} \times L$ is the set of edges and
	\item $I: L \to \mathcal{B}(\mathcal{C})$ assigns invariants to locations. \cite{bengtsson2004timed}
\end{itemize}
\end{dfn}

The automaton's edges are defined by the source location, the guard (represented by a clock constraint), the set of clocks to reset (the timed equivalent of the assignment function), and the target location.
%Graphically a timed automaton can be represented as a labeled graph where the vertices are the locations labelled with their corresponding invariants.

\begin{figure}
	\centering
	\begin{minipage}{0.5\textwidth}
		\includegraphics[width=\textwidth]{include/figures/timed_lamp}%
		\caption{Timed automaton model of a lamp}
		\label{fig:lamp}
	\end{minipage}
\end{figure}

\begin{example}
	The timed automaton depicted in Figure \ref{fig:lamp} models a lamp with three levels of intensity: off (no light), dim, and bright. When it is turned off, one push of the button turns the dim light on, two quick (within 10 time units) pushes of the button turn the bright light on. When it is turned on, it can be switched off with a push of the button.
\end{example}

\begin{dfn}
	A \emph{state} of $\mathcal{A}$ is a pair $\langle l,v \rangle$ where $l \in L$ is a
	location and $v:\mathcal{C} \to \mathds{R}$ is the current valuation satisfying $I(l)$.
\end{dfn}
 In the initial state $\langle l_0,v_0 \rangle$ $v_0$ assigns 0 to each clock variable.

Two kinds of operations are defined.

\begin{dfn}
	 The state $\langle l,v \rangle$ has a
	 \emph{discrete transition} to $\langle l',v' \rangle$  if there is an
	 edge $e(l,g,r,l') \in E$ in the automaton such that 
	 \begin{itemize}
	 	\item $v$ satisfies $g$, 
	 	\item $v'$ assigns 0 to any $c \in r$ and assigns $v(c)$ to any $c \not\in r$, and
	 	\item $v'$ satisfies $I(l')$. 
	 \end{itemize}
\end{dfn}

\begin{dfn}
The state $\langle l,v \rangle$ has a \emph{time transition} (or delay, for short) to $\langle l,v' \rangle$ if
\begin{itemize}
	\item $v'$ assigns $v(c)+d$ for some non-negative $d$ to each $c \in \mathcal{C}$ and
	\item $v'$ satisfies $I(l)$. 
\end{itemize}
\end{dfn}

\begin{example}
	The automaton of the previously mentioned lamp operates on one clock variable, $x$. Initially $x=0$ but as long as the system stays in location \emph{off}, its value increases and it can reach any non-negative value. Once it steps to \emph{dim}, $x$ is reset, and its value increases from 0 again. The next discrete transition is decided by the amount of time the system spent in location \emph{dim}. If it is at most ten time units, the system steps into location \emph{bright} and continues to increase from its last value in \emph{dim}, that can be any value between 0 and 10. Otherwise, the system steps back to \emph{off} and the value of $x$ continues to increase from its last value in \emph{dim}, that is more than 10.
\end{example}

There are many extensions of the timed automata formalism. Most of them -- such as network automata, synchronization, and urgent locations -- can be easily transformed into conventional timed automata, but this is not always the case. The idea to allow discrete variables as well as clock variables arises simply, but the same way as in case of finite automaton, growing expressive power yields less efficient model checking.


\subsection{Timed automaton reachability} \label{sec:tareach}

In case of timed automata the reachability problem can be defined as follows.

\begin{description}
	\item [Input]: An automaton $\mathcal{A}=\langle L, l_0,
	E, I\rangle$, and a location $l_{err} \in L$.
	\item[Output]: An execution trace $\sigma=l_0 \xrightarrow{t_0} l_1 \xrightarrow{t_1} \cdots \xrightarrow{t_n} l_{err}$ from $l_0$ to $l_{err}$ or \emph{No}, if it is unreachable.
\end{description}

This problem is decidable. One of the most effective algorithms for deciding reachability is the algorithm used by \emph{Uppaal}\footnote{http://www.uppaal.org/}, a model checker for timed automata. The core of the algorithm is published in \cite{bengtsson2004timed}.
\subsubsection{Algorithm}

Before presenting the algorithm, some basic definitions have to be provided. First, zones are introduced as an abstract domain for clock valuations.

\begin{dfn}
	A \emph{zone} $z$ is a set of non-negative clock valuations satisfying a clock constraint.
\end{dfn}


\begin{dfn}
	A \emph{zone graph} is a finite graph consisting of $\langle l,z \rangle$ pairs as nodes, where $l \in L$ refers to some location of a timed automaton and $z$ is a zone. Edges of the zone graph represent transitions. 
\end{dfn}

A node $\langle l,z \rangle$ of a zone graph represents all states $\langle l,v \rangle$ where $v \in z$. Since edges of the zone graph denote transitions, a zone graph can be considered as an (exact) abstraction of the state space. The main idea of the algorithm is to explore the zone graph of the timed automaton, and if a node $\langle l_{err},z \rangle$ exists in the graph for some $z \neq \emptyset$, $l_{err}$ is reachable, and the execution trace can be provided by some path-finding algorithm.

The construction of the graph starts with the initial node  $\langle l_0,z_0 \rangle$,
where $l_0$ is the initial location and $z_0$ contains the valuations reachable in the initial location by time transitions. 
Next, for each outgoing edge $e$ of the initial location (in the automaton) a new node  $\langle l,z \rangle$ is created (in the zone graph) with an edge
$\langle l_0,z_0 \rangle \to \langle l,z \rangle$, where $\langle l,z \rangle$ contains the states to which the states in $\langle l_0,z_0 \rangle$ have a discrete transition through $e$. Afterwards $z$ is replaced by $z^\uparrow$ where $z^\uparrow$ denotes the set of all valuations reachable from a zone $z$ by time transitions.  The procedure is repeated on every newly introduced node of the zone graph. If the states defined by a newly introduced node $\langle l,z \rangle$ are all contained in an already existing node $\langle l,z' \rangle$ ($z \subseteq z'$), $\langle l,z \rangle$ can be removed, and the incoming edge should be redirected to $\langle l,z' \rangle$.

\begin{figure} 
	\centering
	\includegraphics[width=.7\textwidth]{include/figures/splitexample_aut}
	\caption{Timed automaton}
	\label{fig:splitex}
\end{figure}

\begin{example}


For ease of understanding the algorithm is demonstrated on the automaton in Figure \ref{fig:splitex}. The initial state is  $\langle S0, z_0 \rangle$ where $z_0$ is a zone containing only the initial valuation $v_0 \equiv 0$. The initial node is  $\langle S0, z_0^\uparrow  \rangle$, where $z_0^\uparrow$ contains all states reachable form the initial state by delay. Since as time passes, the values of the three clocks will be incremented by the same value, $x$, $y$ and $z$ has the same value in each valuation contained by $z_0^\uparrow$. Since there is no invariant in location $S0$ the clocks can take any positive value. Because of this $z_0$ can be defined by the constraint $x=y=z$ (that is, $x-y = 0 \wedge y-z=0 $), and the initial node can be defined as $\langle S0; x=y=z  \rangle$.

There is only one outgoing transition from the initial location and that resets $z$, resulting in the zone defined by $x=y \wedge z=0$, which transforms into $z \leq x=y$ when delay is applied. This means the next node of the graph can be defined as $\langle S1, z \leq x=y \rangle$. There is only one outgoing transition from the location $S1$ and it has guard $y>2$. This means the transition is only enabled in the subzone $z \leq x=y>2$ (that is $z \leq x \wedge x=y \wedge y>2$). The transition resets $y$ resulting in the zone $y=0 \wedge z \leq x > 2$. Delay can be applied and the next node of the graph turns out to be $\langle S2, z \leq x \wedge y \leq z \wedge x-y>2 \rangle$.

The outgoing transition from location $S2$ has a guard $x<z+1 \wedge z<y+1$ from which $x<y+2$ can be derived contradicting the atomic constraint $x-y>2$ in the reachable zone of location $S2$. Thus the transition is never enabled, and location $S3$ is unreachable.

The zone graph of this automaton can be drawn as follows.\[\langle S0; x=y=z  \rangle \to \langle S1, z \leq x=y \rangle \to \langle S2, z \leq x \wedge y \leq z \wedge x-y>2 \rangle \]

\end{example}

\begin{figure}
	\centering
	\begin{minipage}[c] {0.25\linewidth}%
				\vspace*{1pt}%
		\includegraphics [width=\textwidth]{include/figures/loop_example_original}%
		%\caption{A timed automaton}
	\end{minipage}%
		\hspace{0.1\linewidth}%
	\begin{minipage}[c] {0.5\linewidth}%
		\includegraphics [width=\textwidth] {include/figures/loop_original_zonegraph}%
				\vspace*{4pt}%
				%\caption{An imed automaton}
	\end{minipage}
	\caption{Timed automaton with infinite zone graph}
	\label{fig:loopinfinite}
\end{figure} 

Unfortunately, it is possible that the graph described by the previous algorithm becomes infinite. 

\begin{example}

Consider for example the automaton from \cite{bengtsson2004timed} in Figure \ref{fig:loopinfinite}.
Constructing the zone graph of this automaton starts similarly, with the node $\langle \text{\emph{start}}, x=y \rangle$. After that both $x$ and $y$ are reset resulting in the zone defined by $x=y=0$. Location \emph{loop} has an invariant $x \leq 10$ that limits the applicable delay to 10, resulting in $\langle loop, x=y \leq 10 \rangle$, where only the loop-transition is enabled.

The transition resets $x$ resulting in $\langle loop, x=0 \wedge y=10 \rangle$. Still only 10 units of delay is enabled, resulting in the node $\langle loop, x \leq 10 \wedge y-x=10 \rangle$.

From this node, both transitions are enabled. The loop transition increases the difference between $x$ and $y$ yielding the new node $\langle loop, x \leq 10 \wedge y \leq 30 \wedge y-x=20 \rangle$, while the other transition resets both clocks, resulting in the new node $\langle end, x=y \rangle$.

As we take the new node containing the location $loop$, and apply the loop transition over and over, a new node is always constructed with the difference growing. On the other hand, the other transition always results in $\langle end, x=y \rangle$.
Hence the (infinite) zone graph in Figure \ref{fig:loopinfinite}.

\end{example}

In order for the zone graph to be finite, a concept called \emph{normalization} is introduced in \cite{bengtsson2004timed}.

Let $k(c)$ denote the greatest value to which clock $c$ is compared in the automaton.
For any valuation $v$ such that $v(c)>k(c)$ for some $c$, each constraint in the form $c > n$ is satisfied, and each constraint in the form $c = n$ or $c < n$ is unsatisfied, thus the interval $(k(c),\infty)$ can be used as one abstract value for $c$. 

Normalization is performed on $z^\uparrow$ (before inclusion is checked) in two steps. The first step is removing all constraints of the form $x < m, x \leq m, x-y <m, x-y\leq m$ where $m>k(x)$ (so that $x$ doesn't have an upper bound), and the second step is replacing constraints of the form $x > m, x \geq m, x-y >m, x-y\geq m$ where $m>k(x)$ by $x > k(x), x \geq k(x), x-y >k(x), x-y\geq k(x)$ respectively (to define the new lower bounds).

\begin{example}
In the automaton depicted in Figure \ref{fig:loopinfinite}, $k(y)=20$ (and $k(x)=10$). This means the exact value of $y$ doesn't really matter, as long as it is greater than 20 -- the automaton will behave the exact same way if it is between 30 and 40, or if it is between 40 and 50. %We can combine the zones where $y$ is greater than 20 (and the value of $x$ is the same) into the zone $ x \leq 10 \wedge y>20 \wedge y-x>20$.
If we take this into consideration when constructing the zone graph, the zone  $x \leq 10 \wedge y-x=30$ can be normalized. In this zone, $y \geq 30 > k(y)=20$, but $x \leq k(x)$. This means we only have to consider constraints bounding $y$.
Implicitly $y \leq 40$ and $y-x \leq 30$. These constraints have to be removed from the zone. Similarly, $y \geq 30$ and $y-x \geq 30$ have to be replaced by $y \geq 20$ and $y-x \geq 20$. The resulting zone is $x \leq 10 \wedge y \geq 20 \wedge y-x \geq 20$. If we replace the original zone  $x \leq 10 \wedge y-x=30$ by this zone, and continue constructing the zone graph, the resulting graph is depicted in Figure \ref{fig:looprealgraph}.

\end{example}

\begin{figure}
	\centering
	\includegraphics [width=0.4\textwidth] {include/figures/loop_finite_zonegraph}
			\vspace*{4pt}%
	\caption{Finite zone graph}
	\label{fig:looprealgraph}
\end{figure}

Using normalization the zone graph is finite, but unreachable states may appear in it. If the automaton doesn't have any guard or invariant of the form $c_1 - c_2 < n$, the reachability of the location in question will be answered correctly. Otherwise, the algorithm may terminate with a false positive result.

\begin{example}
	To demonstrate the incorrectness of the algorithm, consider again the automaton in Figure \ref{fig:splitex}. Recall that the reachable states of the automaton (by our calculations) were $\langle S0,x=y=z \rangle$, $\langle S1,z \leq x=y \rangle$ and $\langle S2,z \leq y \leq z \leq y \wedge x-y > 2\rangle$ -- $S3$ is unreachable. Applying normalization leaves the states $\langle S0,x=y=z \rangle$ and $\langle S1,z \leq x=y \rangle$ unchanged, but the normalizing the reachable state in $S2$ results in $\langle S2,z \leq y \leq z \leq y \wedge x-y > 1\rangle$, where the guard can be satisfied, thus making $S3$ reachable.
\end{example}

The operation \emph{split} \cite{bengtsson2004timed} is introduced to assure correctness. Instead of
normalizing the complete zone, it is first split along the difference constraints,
then each subzone is normalized, and finally the initially satisfied constraints are reapplied to each normalized subzone. The result is a set of zones (not just one zone like before), which means multiple new nodes have to be introduced to the zone graph (all with edges representing the same transition from the original node).

\begin{example}
To demonstrate the effects of split, let us construct the zone graph of the automaton of Figure \ref{fig:splitex}. The original node remains  $\langle S0,x=y=z \rangle$, but the next node is first split along the difference constraint $x-z<1$. Instead of the node $\langle S1,z \leq x=y \rangle$, this time there are two nodes: $\langle S1, x=y \wedge x-z<1 \rangle$ and $\langle S1, x=y \wedge x-z \geq 1 \rangle$.

From  $\langle S1, x=y \wedge x-z<1 \rangle$,  $\langle S2,x-z \leq 1 \wedge z-y \leq 1\rangle$ is reachable, where the transition to location $S3$ is not enabled because of the guard $x-z < 1$.

From $\langle S1, x=y \wedge x-z \geq 1 \rangle$ the resulting zone after firing the transition is split along the constraint $z-y<1$, resulting in nodes $\langle S2, x-z \geq 1 \wedge z-y < 1\rangle$, and $\langle S2, x-z \geq 1 \wedge z-y \geq 1\rangle$. The transition to $S3$ is not enabled in either nodes. 
\end{example}

Applying split results in a zone graph, that is a correct and finite representation of the state space \cite{bengtsson2004timed}.

\subsubsection{Implementation}

Paper \cite{bengtsson2004timed} also provides an implementation of the zone domain, called \emph{Difference Bound Matrix}, or DBM for short. The idea of DBMs is based on transforming clock constraints to difference logic formulae.

Difference constraints are easy to transform as $c_1 - c_2 \geq n$ is equivalent to $c_2 - c_1 \leq -n$ (same goes for strict inequalities), and $c_1- c_2 = n$ is equivalent to $c_1 - c_2 \geq n \wedge c_1 - c_2 \leq n$. In order to transform constraints of the form $x<n$ or $x \leq n$, $x \in \mathcal{C}, n \in \mathds{Z}$ a new variable has to be introduced. 

\begin{dfn}
	The variable denoted by $\textbf{0}$ is a special variable that has a constant value of 0. $\textbf{0}$ is not a clock variable, but can appear in clock constraints.
\end{dfn}

Using $\textbf{0}$ $x \sim n$,  $\sim \in \{\leq,<,=,>,\geq\}$ can be transformed into $x- \textbf{0} \sim n$, and all clock constraints can be transformed into the desired form. 


\begin{dfn}
	A \emph{Difference Bound Matrix} $D$ of a zone $z$ operating on $\mathcal{C}$ is a square matrix of $\abs{\mathcal{C}}+1$ rows (and columns). A row and a column is assigned to each $c \in (\mathcal{C} \cup \{\textbf{0}\})$. Each element $D_{i,j}$ of the matrix describes an upper bound on $i - j$, by storing whether the inequality is strict ($<$ or $\leq$) and the bound $n$. It is possible that there is no upper bound on $i-j$, in this case $D_{i,j}=\infty$.
	
	The DBM $D$ of zone $z$ stores all constraints bounding $z$.
\end{dfn}

In order for operations to be efficient it is required that the DBM is in a \emph{canonical} form.

\begin{dfn}
	A Difference Bound Matrix $D$ of a zone $z$ is in canonical form if for all $i,j \in (\mathcal{C} \cup \{\textbf{0}\})$, $D_{i,j}$ denotes the strictest bound on $i-j$ that can be derived from $z$.
\end{dfn}

As zones and DBMs are different representations of the same entity, this paper uses the terms interchangeably.

Many operations are defined on DBMs. The most important ones are the following:

\begin{itemize}
	\item \emph{consistent($D$)} is used to decide if $D$ contains any states
	\item \emph{relation($D$,$D'$)} tells if one of $D$ and $D'$ is contained in the other 
	\item \emph{satisfied($D$, $m$)} where $m$ is a difference constraint, tells if $D$ contains any states satisfying $m$ without affecting $D$
	\item \emph{up($D$)} calculates $D^\uparrow$
	% \item \emph{consistent($D$)} is used to decide if the zone represented by $D$ contains any states
	 \item \emph{and($D$, $m$)} where $m$ is a difference constraint, restricts $D$ to the states satisfying $m$
	 \item \emph{free($D$, $c$)} where $c \in \mathcal{C}$,  removes all constraints on $c$
	 \item \emph{reset($D$, $c$)} where $c \in \mathcal{C}$, resets $c$
	 \item \emph{norm($D$, $k$)} where $k:\mathcal{C} \to \mathds{Z}$, normalizes the zone based on $k$ that assigns to each $c \in \mathcal{C}$ the highest value they are compared to in an automaton
	 \item \emph{split($D$, $\mathcal{G}$)} where $\mathcal{G} \in \mathcal{B}(\mathcal{C})$, splits the zone based on $\mathcal{G}$ that is the set of all difference constraints appearing in an automaton.
\end{itemize}

Using these operations the calculation of the next zone in the zone graph can be automated. Let $n=(l,D)$ be an already calculated node of the zone graph, and $e=(l,g,r,l')$ an edge of the timed automaton. Calculating the next node $n'=(l',D)$ (or next nodes) starts by checking guards. This can be performed by calling \emph{and($D$,$m$)} for each atom $m$ of the difference logic formula representation of $g$ and then checking \emph{consistent($D$)} to check if there are any states in $D$ satisfying $g$. If there are, the transition is enabled. In this case $D$ has to be reset: for $c \in r$, \emph{reset($D$,$c$)}. $I(l')$ also has to be satisfied in order for the transition to be enabled. This can be checked similarly to the guard. After this \emph{up} can be used to calculate $D'$, but \emph{and($D$,$m$)} has to be called again for $m \in I(l')$. After that \emph{split} and \emph{norm} are called to ensure correctness and termination.

Implementations (pseudocodes) of these operations are provided in \cite{bengtsson2004timed}. Termination of the algorithm is also proven, but it's complexity is exponential in the number of clocks. Because of this it is essential to reduce the number of clocks as much as it is possible, without changing the reachability property.

\subsubsection{Activity} \label{sec:acitivity}

In \cite{RSS96*73} abstractions of the automaton are proposed to reduce the number of clock variables without affecting the operation of the automaton. The abstraction that will be used later in this paper is called \emph{activity}. A clock $c$ is considered active  at some location $l$ (denoted by $c \in Act(l)$) if its value  at the location may influence the future evolution of the system. It might be because the clock appears in the invariant of the location, or in the guard of some outgoing edges of the location, or because it is active in one of the posterior locations and its value is not reset until that location.
\begin{example}
In the automaton depicted in Figure \ref{fig:splitex} clock $z$ is active at location $S2$ because it appears in the guard of the outgoing edge. It is also active in $S1$ because its value in $S1$ determines its value in $S2$ and it is active in $S2$, but it is not active in $S0$ because its value is not important, since it is reset in the outgoing edge anyway.
\end{example}
The core of the algorithm for reducing the number of clock variables is to calculate $Act(l)$ for each $l \in L$, and if $Act(l)<\abs{\mathcal{C}}$ holds for each $l \in L$, the automaton can be reconstructed by \emph{renaming} variables location by location (after renaming there will be less clocks). This is true, even if all $c \in \mathcal{C}$ is active in at least one location, however, clocks might be renamed differently in distinct locations.

Before presenting how activity is calculated some new notations are introduced. Let $clk: \mathcal{B}(\mathcal{C}) \to 2^\mathcal{C}$ and assign to each clock constraints the set of clocks appear in it. Define $clk:L \to  2^\mathcal{C}$ such that $c \in clk(l)$ iff $c \in clk(I(l))$ or there exist an edge $(l,g,r,l')$ such that $c \in clk(g)$.

\emph{Activity} is calculated by an iterative algorithm starting from $Act_0(l)=clk(l)$ for each $l \in L$. In the $i^{th}$ iteration $Act_{i}(l)$ is derived by extending $Act_{i-1}(l)$ by $Act_{i-1}(l')\setminus r$ for each edge $(l,g,r,l')$. The algorithm terminates when it reaches a fix point, i.e. when $Act_{i}(l)=Act_{i-1}(l)$ for each $l\in L$.

\begin{example}
	Let us calculate activity for the complete automaton. $Act_0(l)=clk(l)$ for each $l \in L$. Thus, iteration starts from $Act_0(S0)=\emptyset$, $Act_0(S1)=\{y\}$, $Act_0(S2)=\{x,y,z\}$, and $Act_0(S3)=\emptyset$. 
	
	Since $y$ is not reset on edge $S0 \to S1$, $Act_1(S0)=\{y\}$. Since $x$ and $z$ are not reset on edge $S1 \to S2$, $Act_1(S1)=\{y,x,z\}$. Since $Act_0(S3)=\emptyset$, and $S3$ has no outgoing edges $Act_1(S2)=\{x,y,z\}$ and $Act_1(S3)=\emptyset$.
	
	Clock $x$ is not reset on edge  $S0 \to S1$ but $z$ is, thus $Act_2(S0)=\{y,x\}$. Other activities are unchanged in this iterations, thus $Act_2(S1)=\{y,x,z\}$, $Act_2(S2)=\{x,y,z\}$, $Act_2(S3)=\emptyset$ and the fix point is reached.
	
\end{example}


\subsubsection{Complexity}

As it was mentioned, reachability for timed automata without discrete variables is decidable (but it it exponential). It was also mentioned before that reachability for finite automata extended by (discrete) variables is undecidable. Obviously, reachability of timed automata extended with discrete variables is also undecidable. However it is decidable if the value sets of the discrete variables are finite, because in this case the values can be encoded in the locations. 

%\todo{network autról beszélni}

%\todo{módszer?}

\section{Objectives}

The goal of this thesis is to provide an extensible framework for CEGAR-based algorithms deciding reachability of timed automata extended with discrete variables. Since reachability is undecidable for this type of timed automata, termination of the algorithms is not always guaranteed.

%\subsection{CEGAR}
%\subsubsection{Abstraction}
%Idea, usefulness, Times automata -- zones, variables, activity, etc. +precisiont is definiálni
%\subsubsection{CEGAR-loop}
%Idea, Cegar-loop, basic cegar ideas (variable-based, state space refinement, etc.)
%This chapter defines the important aspects of timed automata and briefly explains the reachability algorithm presented in \cite{bengtsson2004timed} and demonstrates it on some examples (based on examples, also from \cite{bengtsson2004timed}). CEGAR is also explained at a high level.


%\section{Timed Automata}

%\subsection{Reachability Analysis} \label{sec:reach}  
%
%
%
%
%
%
%%The invariant $x \leq 10$ of location $loop$ is satisfied by $z_0$, but we have to consider it when calculating the valuations reachable by delay -- only the states satisfying $x \leq 10$ of $z_0^\uparrow$ are reachable. The node of the graph can be defined as $\langle loop, x=y \wedge x<10 \rangle$.
%
%%Since there is no state in $\langle loop, x=y \wedge x \leq 10 \rangle$ where $y \geq 20$ holds, the last transition will never be enabled and the zone graph is finished.
%The resulting zone graph is the following.
%
%	\[\langle S0; x=y=z  \rangle \rightarrow \langle S1, z \leq x=y \rangle \rightarrow \langle S2, z \leq x \wedge y \leq z \wedge x-y>2 \rangle \]
%
%\end{example}
%

%

%
%\begin{example}

%
%\end{example}
%	
%xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx%
%%\subsection{Implementation}
%
%\todo{Műveletekről, komplexitásról beszélni!!!}
%
%%\emph{Example:}
%%Fischer's protocol assures mutual exclusion by bounding the execution
%%times of the instructions. It can be applied to a number of processes accessing a
%%shared variable. Fig. \ref{fig:fischer}  shows the operation of a process.
%%The location \emph{critical} indicates that the process is in the critical
%%section. The value of the shared variable $id$ ranges between 0 and $n$,
%%where $n$ denotes the number of processes. The model also contains a 
%%clock variable $x_i$ for each process where $i \in \{1 \ldots n\}$ denotes the
%%identifier of the process. The constant $k$ is a parameter of the automaton.
%
%%\begin{figure}
%%	\centering
%%	\begin{minipage}[c] {0.575\linewidth}%
%%		\vspace*{1pt}%
%%		\includegraphics [width=\textwidth]{fischer_vertical}%
%%		\caption{Fischer's protocol}
%%		\label{fig:fischer}
%%	\end{minipage}%
%%	%
%%	\begin{minipage}[c] {0.425\linewidth}%
%%		\includegraphics [width=\textwidth] {fischer_product_1}%
%%		\vspace*{4pt}%
%%		\caption{Timed automaton}
%%		\label{fig:fischer_product}
%%	\end{minipage}
%%\end{figure}  
%
%%\todo{figure}
%
%%The mutual exclusion property would suggest that at any given time
%%at most one of the processes is in the \emph{critical} location. In order to
%%check the given property we must construct a timed automaton that models the
%%operation of a given number of processes.
%
%%As our definition of timed automaton only allows clock variables in the system,
%%everything else must be encoded in the location.
%%  First, to represent the
%% location of all processes simultaneously, we construct a product automaton
%% containing one location for each of the $4^n$ -- not necessarily reachable --
%% possible combinations. 
%% %For example, the initial location will be \{sleeping, sleeping, \ldots \} with
%% % an outgoing edge to each location containing a combination of $n-1$ sleeping
%% % plus one request label and the corresponding invariant. 
%% The $id$ variable can
%% be encoded in the locations the exact same way.
%% The edges, invariants, etc. should be created approriately.
%% Each location of the result automaton will be denoted by a combination of
%% the four original locations and a number representing $id$'s value. 
%%To
%%demonstrate, Fig.
%%\ref{fig:fischer_product} shows the reachable locations of the product automaton
%%of Fischer's protocol where $n=1$. The names of the locations refer to the original locations of the process, the number denotes the value of the variable $id$.
%
%
%\section{CEGAR}
%
%.
%
